---
cover: "[[gitlabcicd.webp]]"
---
>ðŸ™€ **RECAP GENERATED BY CHATGPT, NOT REVIEWED YET**

# ðŸ’  What is GitLab CI/CD?

GitLab CI/CD is an **integrated DevOps tool** that automates software development workflows, including **building, testing, and deploying applications**. It uses **pipelines** and **jobs** defined in a `.gitlab-ci.yml` file to ensure efficient **Continuous Integration (CI) and Continuous Deployment (CD)**.

### Key Concepts

### **Pipelines**

- A **pipeline** is a sequence of automated tasks executed when code is pushed.
- Defined in `.gitlab-ci.yml`, it consists of **stages** and **jobs**.

### **Stages**

- Stages define **the order of execution** for jobs.
- Example stages:
    - `build` â€“ Compile or package code.
    - `test` â€“ Run tests and check code quality.
    - `deploy` â€“ Deploy application to staging/production.

### **Jobs**

- A **job** is a task inside a pipeline (e.g., running tests, building images).
- Jobs in the **same stage** run in **parallel**; jobs in **different stages** run **sequentially**.

### **Runners**

- A **GitLab Runner** executes CI/CD jobs.
    
- Can be **shared (GitLab-hosted)** or **self-hosted**.
    
- Install a runner locally or on a cloud server:
    
    ```bash
    gitlab-runner register
    ```
    

### **Artifacts & Caching**

- **Artifacts** â€“ Files generated by jobs (e.g., build outputs, test reports).
- **Cache** â€“ Stores dependencies between pipeline runs to speed up execution.

# ðŸ’  Defining Pipelines

A GitLab pipeline is defined in **`.gitlab-ci.yml`** at the **root of the repository**.

### **Minimal Example**

```yaml
stages:
  - build
  - test
  - deploy

build-job:
  stage: build
  script:
    - echo "Building the project"
    - mvn package  # Example for Java

test-job:
  stage: test
  script:
    - echo "Running tests"
    - pytest tests/

deploy-job:
  stage: deploy
  script:
    - echo "Deploying application"
    - ./deploy.sh
```

- **Jobs execute in order (`build â†’ test â†’ deploy`)**.
- **Each job runs inside a fresh environment** (Docker container, VM, or shell).

# ðŸ’  **Runners & Execution Environments**

A **runner** executes CI/CD jobs inside a **specific environment**.

### **Runner Types**

|**Runner Type**|**Use Case**|
|---|---|
|**Shared Runners**|Managed by GitLab, used across projects.|
|**Group Runners**|Available for all projects in a group.|
|**Specific Runners**|Dedicated to a single project.|
|**Self-Hosted Runners**|Installed on a server for private execution.|

### **Installing a GitLab Runner**

```bash
sudo apt update && sudo apt install gitlab-runner
gitlab-runner register
```

- **Runners can use different executors** (`docker`, `shell`, `kubernetes`, `virtualbox`, etc.).
    
- Example: **Docker-based runner**:
    
    ```yaml
    image: node:18  # Use a Node.js environment
    script:
      - npm install
      - npm test
    ```
    

# ðŸ’  **Pipeline Configuration Features**

### **Defining Job Dependencies (`needs`)**

- By default, jobs run sequentially (based on `stages`).
- Use `needs` to **run jobs in parallel**, even across different stages.

```yaml
build:
  stage: build
  script: echo "Building"

test:
  stage: test
  needs: ["build"]  # Test will run only after 'build' finishes
  script: echo "Testing"
```

### **Using Artifacts (Saving Job Outputs)**

```yaml
compile:
  script:
    - make
  artifacts:
    paths:
      - build/output.jar  # Preserve this file for later jobs
    expire_in: 1h  # Automatically delete after 1 hour
```

### **Using Caching (Speed Up Builds)**

```yaml
cache:
  key: dependencies
  paths:
    - node_modules/  # Cache dependencies
```

### **Parallel Execution**

```yaml
test-job:
  stage: test
  script: echo "Running tests"
  parallel: 4  # Run 4 parallel instances
```

# ðŸ’  **Advanced Features**

### **Environment Variables & Secrets**

- Define variables in GitLab UI: **Settings â†’ CI/CD â†’ Variables**.
- Access them in pipelines:

```yaml
deploy:
  script:
    - echo "Deploying to $ENVIRONMENT"
  variables:
    ENVIRONMENT: production
```

### **Conditional Execution (`rules`)**

```yaml
deploy:
  stage: deploy
  script: echo "Deploying..."
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'  # Only deploy if on main branch
```

### **Triggering Pipelines Manually**

```yaml
manual-job:
  stage: deploy
  script: echo "Manual deployment"
  when: manual
```

- **Triggered from the GitLab UI** instead of running automatically.

### **Multi-Project Pipelines**

```yaml
stages:
  - trigger

trigger-downstream:
  stage: trigger
  trigger:
    project: my-org/dependent-repo
    branch: main
```

# ðŸ’  **Continuous Deployment (CD)**

### **Deploy to a Remote Server**

```yaml
deploy:
  stage: deploy
  script:
    - scp app user@server:/var/www/app
```

### **Docker-Based Deployment**

```yaml
deploy:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t myapp .
    - docker run -d -p 80:80 myapp
```

### **Kubernetes Deployment**

```yaml
deploy:
  stage: deploy
  script:
    - kubectl apply -f k8s-deployment.yaml
```

# ðŸ’  **Best Practices**

- **Use `.gitlab-ci.yml` templates** for reusable configurations.
- **Keep jobs small** and focused to improve pipeline efficiency.
- **Use caching & artifacts** to **speed up builds**.
- **Define clear `rules`** to avoid unnecessary pipeline runs.
- **Secure secrets** using **GitLab CI/CD Variables** instead of hardcoding.
- **Monitor pipeline performance** to detect bottlenecks.